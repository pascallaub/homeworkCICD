name: Deploy React App to AWS EC2

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}

jobs:
  ci_build:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build application
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: react-build
          path: dist/
          retention-days: 1

  infra_provision:
    name: Provision Infrastructure
    needs: ci_build
    runs-on: ubuntu-latest
    outputs:
      instance_ip: ${{ steps.terraform_output.outputs.instance_ip }}
      ssh_user: ${{ steps.terraform_output.outputs.ssh_user }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_ACCESS_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"
          terraform_wrapper: false

      - name: Recreate Backend Infrastructure
        run: |
          if ! aws dynamodb describe-table --table-name terraform-locks --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "Creating DynamoDB table for state locking..."
            aws dynamodb create-table \
              --table-name terraform-locks \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
              --region ${{ env.AWS_REGION }}
            aws dynamodb wait table-exists --table-name terraform-locks --region ${{ env.AWS_REGION }}
            echo "DynamoDB table created successfully"
          fi      - name: Cleanup existing infrastructure
        run: |
          echo "Cleaning up existing EC2 infrastructure..."
          
          # Terminate existing EC2 instances
          INSTANCES=$(aws ec2 describe-instances \
            --region ${{ env.AWS_REGION }} \
            --filters "Name=tag:Project,Values=react-cicd" \
                      "Name=instance-state-name,Values=running,stopped,stopping,pending" \
            --query "Reservations[].Instances[].InstanceId" \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$INSTANCES" ] && [ "$INSTANCES" != "None" ]; then
            echo "Found existing instances, terminating..."
            for instance in $INSTANCES; do
              echo "Terminating instance: $instance"
              aws ec2 terminate-instances --instance-ids "$instance" --region ${{ env.AWS_REGION }} || true
            done
            
            echo "Waiting for instances to terminate..."
            for instance in $INSTANCES; do
              aws ec2 wait instance-terminated --instance-ids "$instance" --region ${{ env.AWS_REGION }} || true
            done
          fi
          
          # Clean up key pairs
          EXISTING_KEYS=$(aws ec2 describe-key-pairs \
            --region ${{ env.AWS_REGION }} \
            --query "KeyPairs[?starts_with(KeyName, 'react-cicd')].KeyName" \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$EXISTING_KEYS" ] && [ "$EXISTING_KEYS" != "None" ]; then
            echo "Found existing key pairs, cleaning up..."
            for key in $EXISTING_KEYS; do
              echo "Deleting key pair: $key"
              aws ec2 delete-key-pair --key-name "$key" --region ${{ env.AWS_REGION }} || true
            done
          fi

      - name: Terraform Init
        working-directory: terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Plan
        working-directory: terraform
        run: |
          terraform plan \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="tf_state_bucket=${{ env.TF_STATE_BUCKET }}" \
            -out=tfplan

      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        id: terraform_output
        working-directory: terraform
        run: |
          echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
          echo "ssh_user=$(terraform output -raw ssh_user)" >> $GITHUB_OUTPUT

  app_deploy:
    name: Deploy Application
    needs: infra_provision
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: react-build
          path: dist/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_ACCESS_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"
          terraform_wrapper: false

      - name: Get SSH private key
        working-directory: terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" \
            -backend-config="region=${{ env.AWS_REGION }}"
          terraform output -raw ssh_private_key > ../ssh_key.pem
          chmod 600 ../ssh_key.pem

      - name: Wait for EC2 instance
        run: |
          echo "Waiting for EC2 instance to be ready..."
          for i in {1..30}; do
            if ssh -i ssh_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
               ${{ needs.infra_provision.outputs.ssh_user }}@${{ needs.infra_provision.outputs.instance_ip }} \
               'echo "Instance is ready"' 2>/dev/null; then
              echo "Instance is ready!"
              break
            fi
            echo "Attempt $i: Instance not ready yet, waiting 30 seconds..."
            sleep 30
          done

      - name: Wait for user-data completion
        run: |
          echo "Waiting for user-data script to complete..."
          for i in {1..20}; do
            if ssh -i ssh_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
               ${{ needs.infra_provision.outputs.ssh_user }}@${{ needs.infra_provision.outputs.instance_ip }} \
               'test -f /var/log/user-data.log' 2>/dev/null; then
              echo "User-data script completed!"
              break
            fi
            echo "Attempt $i: Waiting for user-data completion, sleeping 30 seconds..."
            sleep 30
          done

      - name: Prepare web directory
        run: |
          ssh -i ssh_key.pem -o StrictHostKeyChecking=no \
            ${{ needs.infra_provision.outputs.ssh_user }}@${{ needs.infra_provision.outputs.instance_ip }} \
            'sudo mkdir -p /var/www/html && sudo chown -R nginx:nginx /var/www/html && sudo chmod -R 755 /var/www/html'

      - name: Deploy application
        run: |
          scp -i ssh_key.pem -o StrictHostKeyChecking=no -r dist/* \
            ${{ needs.infra_provision.outputs.ssh_user }}@${{ needs.infra_provision.outputs.instance_ip }}:/tmp/

          ssh -i ssh_key.pem -o StrictHostKeyChecking=no \
            ${{ needs.infra_provision.outputs.ssh_user }}@${{ needs.infra_provision.outputs.instance_ip }} \
            'sudo cp -r /tmp/* /var/www/html/ && sudo chown -R nginx:nginx /var/www/html && sudo systemctl reload nginx'

      - name: Health check
        run: |
          echo "Performing health check..."
          for i in {1..10}; do
            if curl -f http://${{ needs.infra_provision.outputs.instance_ip }}/health; then
              echo "Health check passed!"
              break
            fi
            echo "Attempt $i: Health check failed, retrying in 10 seconds..."
            sleep 10
          done

      - name: Display deployment info
        run: |
          echo "Deployment completed successfully!"
          echo "Application URL: http://${{ needs.infra_provision.outputs.instance_ip }}"
          echo "Instance IP: ${{ needs.infra_provision.outputs.instance_ip }}"
